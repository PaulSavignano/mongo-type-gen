import { JSONSchema4 } from 'json-schema';

import fetchCollections from './common/fetchCollections';
import getCollectionsFromFiles from './common/getCollectionsFromFiles';
import getFilenames from './common/getFilenames';
import getValueByKey from './common/getValueByKey';
import singularize from './common/singularize';
import uploadValidatorsAndIndexes from './common/uploadValidatorsAndIndexes';
import watchFilenames from './common/watchFilenames';
import writeCollectionFiles from './common/writeCollectionFiles';
import writeFile from './common/writeFile';
import MtgCollection from './types/MtgCollection';
import MtgConfig from './types/MtgConfig';
import pkg from '../package.json';

const tsMapping: Record<string, string> = {
  bool: 'boolean',
  date: 'Date',
  double: 'number',
  int: 'number',
  objectId: 'ObjectId | string',
  string: 'string',
};

const sdlMapping: Record<string, string> = {
  bool: 'Boolean',
  date: 'Date',
  double: 'Float',
  int: 'Int',
  objectId: 'ObjectId',
  string: 'String',
};

const banner = `/* This file is generated by ${pkg.name}.  Do not edit this file.  Edit the $jsonSchema in in **.collection.ts. */`;

// tab   &#9

const recursor = ({
  allSdls = [],
  allTs = [],
  schemaObj,
  typeName,
}: {
  allSdls: string[];
  allTs: string[];
  schemaObj: Record<string, JSONSchema4>;
  typeName: string;
}) => {
  const tsResult: string[] = [];
  const sdlResult: string[] = [];

  const { properties, required = [] } = schemaObj;
  if (!properties) return;

  const propKeys = Object.keys(properties).sort();

  for (const k of propKeys) {
    const value = properties[k];
    const isKeyRequired = required.includes(k);
    const tsKey = isKeyRequired ? k : `${k}?`;
    const sdlKey = k;
    const properK = k.charAt(0).toUpperCase() + k.slice(1);
    const childType = `${typeName}${properK}`;

    if (value.enum) {
      tsResult.push(`  ${tsKey}: ${childType}Enum;`);
      const enumTs = [
        `export enum ${childType}Enum {`,
        ...value.enum.sort().map((v: string) => `  ${v} = '${v}',`),
        '}',
      ].join('\n');
      allTs.push(enumTs);

      sdlResult.push(`    ${sdlKey}: ${childType}Enum${isKeyRequired ? '!' : ''}`);
      const enumSdl = [`   enum ${childType}Enum {`, ...value.enum.map((v: string) => `    ${v}`), '  }'].join('\n');
      allSdls.push(enumSdl);
      continue;
    }

    if (typeof value.bsonType === 'string') {
      if (value.bsonType === 'array') {
        const mappedItemTs = tsMapping[value.items.bsonType];
        const itemTsValue = mappedItemTs ? mappedItemTs : singularize(childType);
        tsResult.push(`  ${tsKey}: ${itemTsValue}[];`);

        const mappedItemSdl = sdlMapping[value.items.bsonType];
        const itemSdlValue = mappedItemSdl ? mappedItemSdl : singularize(childType);
        sdlResult.push(`    ${sdlKey}: [${itemSdlValue}${isKeyRequired ? '!' : ''}]`);

        if (!mappedItemTs) {
          recursor({
            allSdls,
            allTs,
            schemaObj: value.items,
            typeName: singularize(childType),
          });
        }
        continue;
      }

      if (value.bsonType === 'object') {
        if (!value.properties) {
          tsResult.push(`  ${tsKey}: Record<string, unknown>;`);
          allSdls.unshift('  scalar JSONObject');
          sdlResult.push(`    ${sdlKey}: JSONObject${isKeyRequired ? '!' : ''}`);
          continue;
        }

        tsResult.push(`  ${tsKey}: ${childType};`);
        sdlResult.push(`    ${sdlKey}: ${childType}${isKeyRequired ? '!' : ''}`);
        recursor({
          allSdls,
          allTs,
          schemaObj: value,
          typeName: childType,
        });
        continue;
      }

      const mappedTsValue = tsMapping[value.bsonType];
      const mappedSdlValue = sdlMapping[value.bsonType];

      if (mappedTsValue || mappedTsValue) {
        if (mappedTsValue) {
          tsResult.push(`  ${tsKey}: ${mappedTsValue};`);
        }

        if (mappedSdlValue) {
          sdlResult.push(`    ${sdlKey}: ${mappedSdlValue}${isKeyRequired ? '!' : ''}`);
        }
        continue;
      }
    }

    if (Array.isArray(value.bsonType)) {
      const isValidBsonType = value.bsonType.includes('null') || value.bsonType.length === 1;
      if (!isValidBsonType) {
        throw Error('Only one bsonType and null are supported for a bsonType array at this time');
      }
      const tsValues = value.bsonType
        .map((v: string) => {
          const mapped = tsMapping[v];
          if (v === 'null') {
            return 'null';
          } else if (mapped) {
            return mapped;
          }
          return undefined;
        })
        .filter(Boolean);
      tsResult.push(`  ${tsKey}: ${tsValues.join(' | ')};`);

      const sdlValues = value.bsonType.filter((v: string) => v !== 'null');
      sdlResult.push(`    ${sdlKey}: ${sdlMapping[sdlValues[0]]}${isKeyRequired ? '!' : ''}`);
    }
  }

  allTs.push([`export type ${typeName} = {`, ...tsResult, '};'].join('\n'));
  allSdls.push([`  type ${typeName} {`, ...sdlResult, '  }'].join('\n'));
};

const typeGenerator = async ({
  collections,
  output,
}: {
  collections: MtgCollection[];
  output: MtgConfig['output'];
}) => {
  const tsHeader: string[] = [banner, "import { ObjectId } from 'mongodb';"];
  const sdlsHeader: string[] = [banner, "import { gql } from 'graphql-tag';", 'export default gql`'];
  const allTs: string[] = [];
  const allSdls: string[] = [];

  const collectionNames = collections.map((c) => c.name);
  const tsCollectionNameEnumValues = collectionNames.sort().map((v) => `  ${v} = '${v}',`);
  const tsCollectionNameEnum = ['export enum CollectionEnum {', ...tsCollectionNameEnumValues, '}'].join('\n');
  allTs.push(tsCollectionNameEnum);

  const sdlCollectionNameEnumValues = collectionNames.map((v) => `    ${v}`);
  const sdlCollectionNameEnum = ['  enum CollectionEnum {', ...sdlCollectionNameEnumValues, '  }'].join('\n');
  allSdls.push(sdlCollectionNameEnum);

  for (const c of collections) {
    const $jsonSchema = getValueByKey(c, '$jsonSchema');

    if (!$jsonSchema) {
      console.warn(
        `ðŸŸ¡ ${pkg.name} could not find a $jsonSchema property in ${c.name}.collection.ts and is skipping that collection`,
      );
      continue;
    }

    const properCaseCollectionName = c.name.charAt(0).toUpperCase() + c.name.slice(1);
    const singularCollectionName = singularize(properCaseCollectionName);

    recursor({
      allSdls,
      allTs,
      schemaObj: $jsonSchema as JSONSchema4,
      typeName: `${singularCollectionName}Doc`,
    });
  }

  const tsFileString = [...tsHeader, ...allTs].join('\n\n');
  const sdlFileString = [...sdlsHeader, ...allSdls, '`;'].join('\n\n');

  const writeFilePromises = [writeFile({ data: tsFileString, dir: output.types, file: 'mongo.types.ts' })];

  if (output.sdls) {
    writeFilePromises.push(writeFile({ data: sdlFileString, dir: output.sdls || output.types, file: 'mongo.sdls.ts' }));
  }

  await Promise.all(writeFilePromises);

  console.info(`âœ… ${pkg.name} types generated!`);
};

const genTypes = async ({ db, input, isWatching, output, uri }: MtgConfig & { isWatching?: boolean }) => {
  if (input) {
    const filenames = await getFilenames(input);

    if (!filenames.length) {
      console.info(`âš ï¸ ${pkg.name} could not find any collection files, attempting to download from Mongo...`);
      const collections = await fetchCollections({ db, uri });
      if (!collections.length) {
        console.info(`ðŸ“¡ ${pkg.name} could not find any collections in Mongo, exiting...`);
        return;
      }
      if (!output.collections && isWatching) {
        console.warn(
          `âš ï¸ ${pkg.name} did not find an output directory to write collections to and does not have files to watch for changes.`,
        );
      }
      if (output.collections) {
        await writeCollectionFiles({ collections, dir: output.collections });
      }
      return typeGenerator({ collections, output });
    }

    const generate = async () => {
      const collections = await getCollectionsFromFiles(filenames);
      await uploadValidatorsAndIndexes({ collections, db, uri });
      await typeGenerator({ collections, output });
    };
    if (isWatching && filenames.length) {
      watchFilenames({ filenames, onChange: generate });
    }
    await generate();
  } else {
    const collections = await fetchCollections({ db, uri });
    await typeGenerator({ collections, output });
  }
};

export default genTypes;
