{
  "version": 3,
  "sources": ["../src/genTypes.ts", "../src/common/getFullPaths.ts", "../src/common/getConfig.ts", "../src/common/singularize.ts", "../src/common/watchDirs.ts", "../src/common/writeFileAsync.ts"],
  "sourcesContent": ["import fs from 'fs';\nimport { JSONSchema4 } from 'json-schema';\nimport { transpile } from 'typescript';\n\nimport getConfig from './common/getConfig';\nimport getFullPaths from './common/getFullPaths';\nimport singularize from './common/singularize';\nimport watchDirs from './common/watchDirs';\nimport writeFileAsync from './common/writeFileAsync';\nimport pkg from '../package.json';\n\nconst typeMapping: Record<string, string> = {\n  bool: 'boolean',\n  date: 'Date',\n  double: 'number',\n  int: 'number',\n  objectId: 'ObjectId | string',\n  string: 'string',\n};\n\nconst sdlMapping: Record<string, string> = {\n  bool: 'Boolean',\n  date: 'Date',\n  double: 'Float',\n  int: 'Int',\n  objectId: 'ObjectId',\n  string: 'String',\n};\n\n// tab   &#9\n\nconst reduce = ({\n  allSdls = [],\n  allTypes = [],\n  collectionName,\n  obj,\n}: {\n  allSdls: string[];\n  allTypes: string[];\n  collectionName: string;\n  obj: Record<string, JSONSchema4>;\n}) => {\n  const { properties, required = [] } = obj;\n  const typeResult: string[] = [];\n  const sdlResult: string[] = [];\n\n  const propKeys = Object.keys(properties).sort();\n  for (const k of propKeys) {\n    const value = properties[k];\n    const isKeyRequired = required.includes(k);\n    const typeKey = isKeyRequired ? k : `${k}?`;\n    const sdlKey = k;\n\n    const properK = k.charAt(0).toUpperCase() + k.slice(1);\n    const childType = `${collectionName}${properK}`;\n\n    if (value.enum) {\n      const enumType = [\n        `export enum ${childType}Enum {`,\n        ...value.enum.sort().map((v: string) => `  ${v} = '${v}',`),\n        '}',\n      ].join('\\n');\n      allTypes.push(enumType);\n\n      const enumSdl = [`   enum ${childType}Enum {`, ...value.enum.map((v: string) => `    ${v}`), '  }'].join('\\n');\n      allSdls.push(enumSdl);\n      continue;\n    }\n\n    if (typeof value.bsonType === 'string') {\n      if (value.bsonType === 'array') {\n        const mappedItemType = typeMapping[value.items.bsonType];\n        const itemTypeValue = mappedItemType ? mappedItemType : childType;\n        const mappedItemSdl = sdlMapping[value.items.bsonType];\n        const itemSdlValue = mappedItemSdl ? mappedItemSdl : childType;\n        typeResult.push(`  ${typeKey}: ${itemTypeValue}[];`);\n        sdlResult.push(`    ${sdlKey}: [${itemSdlValue}${isKeyRequired ? '!' : ''}]`);\n        if (!mappedItemType) {\n          reduce({\n            allSdls,\n            allTypes,\n            collectionName: childType,\n            obj: value.items,\n          });\n        }\n\n        continue;\n      }\n\n      if (value.bsonType === 'object') {\n        typeResult.push(`  ${typeKey}: ${childType};`);\n        sdlResult.push(`    ${sdlKey}: ${childType}${isKeyRequired ? '!' : ''}`);\n        reduce({\n          allSdls,\n          allTypes,\n          collectionName: childType,\n          obj: value,\n        });\n        continue;\n      }\n\n      const mappedTypeValue = typeMapping[value.bsonType];\n      const mappedSdlValue = sdlMapping[value.bsonType];\n\n      if (mappedTypeValue || mappedTypeValue) {\n        if (mappedTypeValue) {\n          typeResult.push(`  ${typeKey}: ${mappedTypeValue};`);\n        }\n\n        if (mappedSdlValue) {\n          sdlResult.push(`    ${sdlKey}: ${mappedSdlValue}${isKeyRequired ? '!' : ''}`);\n        }\n        continue;\n      }\n    }\n\n    if (Array.isArray(value.bsonType)) {\n      const valid = value.bsonType.includes('null') || value.bsonType.length === 1;\n      if (!valid) {\n        throw Error('Only one bsonType and null are supported for a bsonType array');\n      }\n      // handle Typescript\n      const res: string[] = [];\n      value.bsonType.forEach((v: string) => {\n        const mapped = typeMapping[v];\n        if (v === 'null') {\n          res.push('null');\n        } else if (mapped) {\n          res.push(mapped);\n        }\n      });\n      typeResult.push(`  ${typeKey}: ${res.join(' | ')};`);\n\n      // handle SDL\n      const singleType = value.bsonType.filter((v: string) => v !== 'null');\n      sdlResult.push(`    ${sdlKey}: ${sdlMapping[singleType[0]]}${isKeyRequired ? '!' : ''}`);\n    }\n  }\n\n  allTypes.push([`export type ${collectionName} = {`, ...typeResult, '};'].join('\\n'));\n  allSdls.push([`  type ${collectionName} {`, ...sdlResult, '  }'].join('\\n'));\n};\n\nconst iterateValidators = async ({ outputPath, validatorPaths }: { outputPath: string; validatorPaths: string[] }) => {\n  const banner = '/* This file is generated by mongo-type-gen.  Do not edit */';\n  const allTypes: string[] = [banner, \"import { ObjectId } from 'mongodb';\"];\n  const allSdls: string[] = [banner, \"import { gql } from 'graphql-tag';\", 'export default gql`'];\n\n  for (const path of validatorPaths) {\n    const validatorStr = fs.readFileSync(path, 'utf8');\n    const validator = transpile(validatorStr);\n    const v = eval(validator);\n    const cName = path.split('/').pop()?.split('.')[0] || '';\n    const properCname = cName.charAt(0).toUpperCase() + cName.slice(1);\n    const singularCname = singularize(properCname);\n    reduce({\n      allSdls,\n      allTypes,\n      collectionName: `${singularCname}Doc`,\n      obj: v.$jsonSchema,\n    });\n  }\n\n  const tsString = allTypes.join('\\n\\n');\n  const sdlString = [...allSdls, '`;'].join('\\n\\n');\n\n  await Promise.all([\n    writeFileAsync(`./${outputPath}/mongo.types.ts`, tsString),\n    writeFileAsync(`./${outputPath}/mongo.sdls.ts`, sdlString),\n  ]);\n\n  console.info(`\u2705 ${pkg.name} types generated!`);\n};\n\nconst genTypes = async () => {\n  const config = await getConfig();\n  const validatorPaths = await getFullPaths('**/*.validator.*s');\n\n  if (process.argv.includes('--watch') || process.argv.includes('-w')) {\n    const onChange = async () =>\n      iterateValidators({\n        outputPath: config.output,\n        validatorPaths,\n      });\n    watchDirs({\n      dirs: validatorPaths,\n      onChange,\n    });\n  }\n\n  iterateValidators({\n    outputPath: config.output,\n    validatorPaths,\n  });\n};\n\ngenTypes();\n", "import fg from 'fast-glob';\nimport path from 'path';\n\nconst getFullPaths = async (glob: string[] | string) => {\n  const paths = await fg(glob, { absolute: true, ignore: ['**/node_modules/**'] });\n  console.log('paths are ', paths);\n  const mainFileDir = path.dirname(process.argv[1]);\n  const resolvedGlobs = paths.map((p) => path.resolve(mainFileDir, p));\n  return resolvedGlobs;\n};\n\nexport default getFullPaths;\n", "import getFullPaths from './getFullPaths';\nimport pkg from '../../package.json';\n\nconst getConfig = async () => {\n  const configPaths = await getFullPaths(['**/mtg.config.*s', '**/mongo-type-gen.config.*s']);\n  if (configPaths.length > 1) {\n    throw Error(\n      `\u274C ${pkg.name} found multiple config files: \\n${configPaths.join('\\n')}\\nPlease only use one config file.`,\n    );\n  }\n  const configFile = await import(configPaths[0]);\n  return configFile.default;\n};\n\nexport default getConfig;\n", "function singularize(name: string): string {\n  // Define common plural-to-singular conversion rules\n  const pluralToSingular: { [plural: string]: string } = {\n    es: '',\n    ies: 'y',\n    oes: 'o',\n    s: '',\n    ves: 'f',\n    xes: 'x',\n  };\n\n  // Check if the plural name matches any of the conversion rules\n  for (const pluralSuffix in pluralToSingular) {\n    if (name.endsWith(pluralSuffix)) {\n      return name.slice(0, -pluralSuffix.length) + pluralToSingular[pluralSuffix];\n    }\n  }\n\n  // If no match found in the rules, return the original name\n  return name;\n}\n\nexport default singularize;\n", "import fs from 'fs';\n\nimport pkg from '../../package.json';\n\nfunction watchDirs({ dirs, onChange }: { dirs: string[]; onChange: () => Promise<void> }) {\n  console.info(`\u2705 ${pkg.name} watching: ${dirs.join(', ')}`);\n\n  let isChanging = false;\n  dirs.forEach((dir) => {\n    const watcher = fs.watch(dir, { recursive: true });\n    watcher.on('change', (_eventType, filename) => {\n      if (!isChanging) {\n        isChanging = true;\n        onChange();\n        if (filename) {\n          setTimeout(() => {\n            isChanging = false;\n          }, 2000);\n        }\n      }\n    });\n\n    watcher.on('error', (error) => {\n      console.error(`watchDirs error: ${error}`);\n    });\n\n    // Event listener for 'close' event (optional)\n    watcher.on('close', () => {\n      console.log('watchDirs closed');\n    });\n  });\n}\n\nexport default watchDirs;\n", "import fs from 'fs';\nimport { promisify } from 'util';\n\nconst writeFileAsync = promisify(fs.writeFile);\n\nexport default writeFileAsync;\n"],
  "mappings": "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",
  "names": ["import_fs", "fg", "path", "pkg", "import_package", "pkg", "fs", "import_fs", "fs", "import_package", "allSdls", "allTypes", "v", "fs", "pkg", "validatorPaths"]
}
