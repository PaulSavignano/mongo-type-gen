{
  "version": 3,
  "sources": ["../src/genTypes.ts", "../src/common/getFullPaths.ts", "../src/common/getConfig.ts", "../src/common/singularize.ts", "../src/common/watchDirs.ts", "../src/common/writeFileAsync.ts", "../src/downloadValidators.ts", "../src/common/formatJsonSting.ts"],
  "sourcesContent": ["import fs from 'fs';\nimport { JSONSchema4 } from 'json-schema';\nimport { transpile } from 'typescript';\n\nimport getConfig from './common/getConfig';\nimport getFullPaths from './common/getFullPaths';\nimport singularize from './common/singularize';\nimport watchDirs from './common/watchDirs';\nimport writeFileAsync from './common/writeFileAsync';\nimport downloadValidators from './downloadValidators';\nimport pkg from '../package.json';\n\nconst typeMapping: Record<string, string> = {\n  bool: 'boolean',\n  date: 'Date',\n  double: 'number',\n  int: 'number',\n  objectId: 'ObjectId | string',\n  string: 'string',\n};\n\nconst sdlMapping: Record<string, string> = {\n  bool: 'Boolean',\n  date: 'Date',\n  double: 'Float',\n  int: 'Int',\n  objectId: 'ObjectId',\n  string: 'String',\n};\n\n// tab   &#9\n\nconst reduce = ({\n  allSdls = [],\n  allTypes = [],\n  collectionName,\n  obj,\n}: {\n  allSdls: string[];\n  allTypes: string[];\n  collectionName: string;\n  obj: Record<string, JSONSchema4>;\n}) => {\n  const { properties, required = [] } = obj;\n  const typeResult: string[] = [];\n  const sdlResult: string[] = [];\n\n  const propKeys = Object.keys(properties).sort();\n  for (const k of propKeys) {\n    const value = properties[k];\n    const isKeyRequired = required.includes(k);\n    const typeKey = isKeyRequired ? k : `${k}?`;\n    const sdlKey = k;\n\n    const properK = k.charAt(0).toUpperCase() + k.slice(1);\n    const childType = `${collectionName}${properK}`;\n\n    if (value.enum) {\n      const enumType = [\n        `export enum ${childType}Enum {`,\n        ...value.enum.sort().map((v: string) => `  ${v} = '${v}',`),\n        '}',\n      ].join('\\n');\n      allTypes.push(enumType);\n\n      const enumSdl = [`   enum ${childType}Enum {`, ...value.enum.map((v: string) => `    ${v}`), '  }'].join('\\n');\n      allSdls.push(enumSdl);\n      continue;\n    }\n\n    if (typeof value.bsonType === 'string') {\n      if (value.bsonType === 'array') {\n        const mappedItemType = typeMapping[value.items.bsonType];\n        const itemTypeValue = mappedItemType ? mappedItemType : childType;\n        const mappedItemSdl = sdlMapping[value.items.bsonType];\n        const itemSdlValue = mappedItemSdl ? mappedItemSdl : childType;\n        typeResult.push(`  ${typeKey}: ${itemTypeValue}[];`);\n        sdlResult.push(`    ${sdlKey}: [${itemSdlValue}${isKeyRequired ? '!' : ''}]`);\n        if (!mappedItemType) {\n          reduce({\n            allSdls,\n            allTypes,\n            collectionName: childType,\n            obj: value.items,\n          });\n        }\n\n        continue;\n      }\n\n      if (value.bsonType === 'object') {\n        typeResult.push(`  ${typeKey}: ${childType};`);\n        sdlResult.push(`    ${sdlKey}: ${childType}${isKeyRequired ? '!' : ''}`);\n        reduce({\n          allSdls,\n          allTypes,\n          collectionName: childType,\n          obj: value,\n        });\n        continue;\n      }\n\n      const mappedTypeValue = typeMapping[value.bsonType];\n      const mappedSdlValue = sdlMapping[value.bsonType];\n\n      if (mappedTypeValue || mappedTypeValue) {\n        if (mappedTypeValue) {\n          typeResult.push(`  ${typeKey}: ${mappedTypeValue};`);\n        }\n\n        if (mappedSdlValue) {\n          sdlResult.push(`    ${sdlKey}: ${mappedSdlValue}${isKeyRequired ? '!' : ''}`);\n        }\n        continue;\n      }\n    }\n\n    if (Array.isArray(value.bsonType)) {\n      const valid = value.bsonType.includes('null') || value.bsonType.length === 1;\n      if (!valid) {\n        throw Error('Only one bsonType and null are supported for a bsonType array');\n      }\n      // handle Typescript\n      const res: string[] = [];\n      value.bsonType.forEach((v: string) => {\n        const mapped = typeMapping[v];\n        if (v === 'null') {\n          res.push('null');\n        } else if (mapped) {\n          res.push(mapped);\n        }\n      });\n      typeResult.push(`  ${typeKey}: ${res.join(' | ')};`);\n\n      // handle SDL\n      const singleType = value.bsonType.filter((v: string) => v !== 'null');\n      sdlResult.push(`    ${sdlKey}: ${sdlMapping[singleType[0]]}${isKeyRequired ? '!' : ''}`);\n    }\n  }\n\n  allTypes.push([`export type ${collectionName} = {`, ...typeResult, '};'].join('\\n'));\n  allSdls.push([`  type ${collectionName} {`, ...sdlResult, '  }'].join('\\n'));\n};\n\nconst iterateValidators = async ({ outputPath, validatorPaths }: { outputPath: string; validatorPaths: string[] }) => {\n  const banner = '/* This file is generated by mongo-type-gen.  Do not edit */';\n  const allTypes: string[] = [banner, \"import { ObjectId } from 'mongodb';\"];\n  const allSdls: string[] = [banner, \"import { gql } from 'graphql-tag';\", 'export default gql`'];\n\n  for (const path of validatorPaths) {\n    const validatorStr = fs.readFileSync(path, 'utf8');\n    const validator = transpile(validatorStr);\n    const v = eval(validator);\n    const cName = path.split('/').pop()?.split('.')[0] || '';\n    const properCname = cName.charAt(0).toUpperCase() + cName.slice(1);\n    const singularCname = singularize(properCname);\n    reduce({\n      allSdls,\n      allTypes,\n      collectionName: `${singularCname}Doc`,\n      obj: v.$jsonSchema,\n    });\n  }\n\n  const tsString = allTypes.join('\\n\\n');\n  const sdlString = [...allSdls, '`;'].join('\\n\\n');\n\n  await Promise.all([\n    writeFileAsync(`./${outputPath}/mongo.types.ts`, tsString),\n    writeFileAsync(`./${outputPath}/mongo.sdls.ts`, sdlString),\n  ]);\n\n  console.info(`\u2705 ${pkg.name} types generated!`);\n};\n\nconst genTypes = async () => {\n  const config = await getConfig();\n  const isWatching = process.argv.includes('--watch') || process.argv.includes('-w');\n  const validatorPaths = await getFullPaths('**/*.validator.*s');\n\n  if (!validatorPaths.length) {\n    console.info(`\u26A0\uFE0F ${pkg.name} could not find any validators files, downnloading from Mongo...`);\n    await downloadValidators();\n  }\n\n  if (isWatching) {\n    const onChange = async () =>\n      iterateValidators({\n        outputPath: config.output,\n        validatorPaths,\n      });\n    watchDirs({\n      dirs: validatorPaths,\n      onChange,\n    });\n  }\n\n  iterateValidators({\n    outputPath: config.output,\n    validatorPaths,\n  });\n};\n\ngenTypes().catch((e) => {\n  console.error('\u274C genTypes failed: ', e);\n  process.exit(1);\n});\n", "import fg from 'fast-glob';\nimport path from 'path';\n\nconst getFullPaths = async (glob: string[] | string) => {\n  const paths = await fg(glob, { absolute: true, ignore: ['**/node_modules/**'] });\n  const mainFileDir = path.dirname(process.argv[1]);\n  const resolvedGlobs = paths.map((p) => path.resolve(mainFileDir, p));\n  return resolvedGlobs;\n};\n\nexport default getFullPaths;\n", "import getFullPaths from './getFullPaths';\nimport pkg from '../../package.json';\n\nconst getConfig = async () => {\n  const configPaths = await getFullPaths(['**/mtg.config.*s', '**/mongo-type-gen.config.*s']);\n  const configFile = await import(configPaths[0]);\n  if (configPaths.length > 1) {\n    console.log(`\uD83D\uDFE1 ${pkg.name} found multiple config files.  Using ${configPaths[0]}.`);\n  }\n\n  return configFile.default;\n};\n\nexport default getConfig;\n", "function singularize(name: string): string {\n  // Define common plural-to-singular conversion rules\n  const pluralToSingular: { [plural: string]: string } = {\n    es: '',\n    ies: 'y',\n    oes: 'o',\n    s: '',\n    ves: 'f',\n    xes: 'x',\n  };\n\n  // Check if the plural name matches any of the conversion rules\n  for (const pluralSuffix in pluralToSingular) {\n    if (name.endsWith(pluralSuffix)) {\n      return name.slice(0, -pluralSuffix.length) + pluralToSingular[pluralSuffix];\n    }\n  }\n\n  // If no match found in the rules, return the original name\n  return name;\n}\n\nexport default singularize;\n", "import fs from 'fs';\n\nimport pkg from '../../package.json';\n\nfunction watchDirs({ dirs, onChange }: { dirs: string[]; onChange: () => Promise<void> }) {\n  console.info(`\u2705 ${pkg.name} watching: ${dirs.join(', ')}`);\n\n  let isChanging = false;\n  dirs.forEach((dir) => {\n    const watcher = fs.watch(dir, { recursive: true });\n    watcher.on('change', (_eventType, filename) => {\n      if (!isChanging) {\n        isChanging = true;\n        onChange();\n        if (filename) {\n          setTimeout(() => {\n            isChanging = false;\n          }, 2000);\n        }\n      }\n    });\n\n    watcher.on('error', (error) => {\n      console.error(`watchDirs error: ${error}`);\n    });\n\n    // Event listener for 'close' event (optional)\n    watcher.on('close', () => {\n      console.log('watchDirs closed');\n    });\n  });\n}\n\nexport default watchDirs;\n", "import fs from 'fs';\nimport { promisify } from 'util';\n\nconst writeFileAsync = promisify(fs.writeFile);\n\nexport default writeFileAsync;\n", "//import fs from 'fs';\nimport { MongoClient } from 'mongodb';\n\nimport formatJsonString from './common/formatJsonSting';\nimport getConfig from './common/getConfig';\nimport writeFileAsync from './common/writeFileAsync';\nimport pkg from '../package.json';\n\n// Replace the uri string with your MongoDB deployment's connection string.\nlet client: MongoClient;\n\nasync function downloadValidators(): Promise<number> {\n  try {\n    const config = await getConfig();\n    if (!config.uri) {\n      throw Error('I cannot connect to download your validators from Mongo without a uri.');\n    }\n    const files = [];\n    const banner = '/* This file is generated by mongo-type-gen.  Do not edit */';\n\n    client = new MongoClient(config.uri);\n\n    const db = client.db(config.db);\n    const listCollections = await db.listCollections().toArray();\n\n    for (const col of listCollections) {\n      const c = col as unknown as { options: { validator: string } };\n      const v = c.options.validator;\n      const s = formatJsonString(v);\n\n      const tsCode = [banner, `export default ${s};`].join('\\n\\n');\n      const file = writeFileAsync(`./${config.output}/${col.name}.validator.ts`, tsCode);\n      files.push(file);\n    }\n\n    await Promise.all(files);\n    console.info(`\u2705 ${pkg.name} validators downloaded from Mongo!`);\n    return 0;\n  } catch (e) {\n    const error = e instanceof Error ? e.message : e;\n    console.error(`\u274C ${pkg.name} failed to download validators from Mongo: `, error);\n    return 1;\n  } finally {\n    await client.close();\n  }\n}\n\nexport default downloadValidators;\n", "const formatJsonString = (obj: unknown): string => {\n  if (!obj) return '';\n  const keys = Object.keys(obj);\n  if (!keys || !keys.length) return '{}';\n  const json = JSON.stringify(obj, null, 2);\n  const removeDoubleQuoteKeys = json.replace(/\"([^\"]+)\":/g, '$1:');\n  const replaceDoubleQuotes = removeDoubleQuoteKeys.replace(/\"([^\"]*)\"/g, (p, p1) => {\n    if (p1.includes(\"'\")) {\n      return `\"${p1}\"`; // Use single quotes if value contains single quotes\n    }\n    return `'${p1}'`; // Use double quotes otherwise\n  });\n  // const addOpeningBraketSpacing = replaceDoubleQuotes.replace(/[[]/g, '[ ');\n  // const addClosingBraketSpacing = addOpeningBraketSpacing.replace(/]/g, ' ]');\n  // const addOpeningBraceSpacing = addClosingBraketSpacing.replace(/{/g, '{ ');\n  // const addClosingBraceSpacing = addOpeningBraceSpacing.replace(/}/g, ' }');\n  // const addComaSpacing = addClosingBraceSpacing.replace(/,/g, ', ');\n  return replaceDoubleQuotes;\n};\n\nexport default formatJsonString;\n"],
  "mappings": "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",
  "names": ["import_fs", "import_typescript", "import_fast_glob", "import_path", "getFullPaths", "glob", "paths", "fg", "mainFileDir", "path", "p", "getFullPaths_default", "import_package", "getConfig", "configPaths", "getFullPaths_default", "configFile", "pkg", "getConfig_default", "singularize", "name", "pluralToSingular", "pluralSuffix", "singularize_default", "import_fs", "import_package", "watchDirs", "dirs", "onChange", "pkg", "isChanging", "dir", "watcher", "fs", "_eventType", "filename", "error", "watchDirs_default", "import_fs", "import_util", "writeFileAsync", "fs", "writeFileAsync_default", "import_mongodb", "formatJsonString", "obj", "keys", "p1", "formatJsonSting_default", "import_package", "client", "downloadValidators", "config", "getConfig_default", "files", "banner", "listCollections", "col", "v", "s", "formatJsonSting_default", "tsCode", "file", "writeFileAsync_default", "pkg", "e", "error", "downloadValidators_default", "import_package", "typeMapping", "sdlMapping", "reduce", "allSdls", "allTypes", "collectionName", "obj", "properties", "required", "typeResult", "sdlResult", "propKeys", "k", "value", "isKeyRequired", "typeKey", "sdlKey", "properK", "childType", "enumType", "v", "enumSdl", "mappedItemType", "itemTypeValue", "mappedItemSdl", "itemSdlValue", "mappedTypeValue", "mappedSdlValue", "res", "mapped", "singleType", "iterateValidators", "fs", "singularize_default", "writeFileAsync_default", "pkg", "genTypes", "config", "getConfig_default", "isWatching", "validatorPaths", "getFullPaths_default", "downloadValidators_default", "watchDirs_default", "e"]
}
